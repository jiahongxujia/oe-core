From 4a6b6c0e1b4465ada1ad0593e8c8fbcfcfb40c72 Mon Sep 17 00:00:00 2001
From: Hongxu Jia <hongxu.jia@windriver.com>
Date: Mon, 11 Jun 2018 21:52:10 +0800
Subject: [PATCH] decrypt password

Invoke openssl cli to decrypt password

Upstream-Status: Inappropriate [pulsar specific]

Signed-off-by: Hongxu Jia <hongxu.jia@windriver.com>
---
 librepo/handle.c | 74 +++++++++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 71 insertions(+), 3 deletions(-)

diff --git a/librepo/handle.c b/librepo/handle.c
index ff39db4..43e4016 100644
--- a/librepo/handle.c
+++ b/librepo/handle.c
@@ -234,6 +234,69 @@ lr_handle_remote_sources_changed(LrHandle *handle, LrChangedRemoteSource type)
     }
 }
 
+static int invoke_program(const char*cmd, char *out, int out_len)
+{
+    FILE *fp;
+
+#ifdef DEBUG
+    printf("CMD: %s\n", cmd);
+#endif
+    if ((fp = popen(cmd, "r")) == NULL)
+    {
+        printf("Error opening pipe!\n");
+        return -1;
+    }
+
+    while (fgets(out, out_len, fp) != NULL)
+    {
+#ifdef DEBUG
+        printf("OUTPUT: %s", out);
+#endif
+
+        // Strip newline
+        char *pos;
+        if ((pos=strchr(out, '\n')) != NULL)
+           *pos = '\0';
+    }
+
+    if(pclose(fp))
+    {
+#ifdef DEBUG
+        printf("Command not found or exited with error status\n");
+#endif
+        return -1;
+    }
+
+    return 0;
+}
+
+
+static gboolean
+decrypt_password (char *userpass, char *userpass_decrypt)
+{
+    char *username = strtok(userpass, ":");
+    if (username == NULL)
+        return FALSE;
+
+    char *encrypt_password = strtok(NULL, "");
+    if (encrypt_password == NULL)
+        return FALSE;
+
+    char cmd[1024];
+    char out[1024];
+    sprintf(cmd, "echo %s | openssl enc -d -aes-256-cbc -md md5 -base64 -salt -pass pass:%s 2>/dev/null",
+                  encrypt_password, "incendia");
+    if (invoke_program(cmd, out, sizeof(out)))
+        return FALSE;
+
+    sprintf(userpass_decrypt, "%s:%s", username, out);
+
+#ifdef DEBUG
+    printf("%s %d, %s -> %s\n", __FUNCTION__, __LINE__, userpass, userpass_decrypt);
+#endif
+  return TRUE;
+}
+
 gboolean
 lr_handle_setopt(LrHandle *handle,
                  GError **err,
@@ -319,10 +382,15 @@ lr_handle_setopt(LrHandle *handle,
         }
         break;
 
-    case LRO_USERPWD:
-        c_rc = curl_easy_setopt(c_h, CURLOPT_USERPWD, va_arg(arg, char *));
-        break;
+    case LRO_USERPWD: {
+        char *userpass = va_arg(arg, char *);
+        char userpass_decrypt[1024];
 
+        strcpy(userpass_decrypt, userpass);
+        decrypt_password (userpass, userpass_decrypt);
+        c_rc = curl_easy_setopt(c_h, CURLOPT_USERPWD, userpass_decrypt);
+        break;
+    }
     case LRO_PROXY:
         c_rc = curl_easy_setopt(c_h, CURLOPT_PROXY, va_arg(arg, char *));
         break;
-- 
2.7.4

